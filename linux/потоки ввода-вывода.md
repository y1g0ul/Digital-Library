---
created-dt: 2025-08-20 15:19
tags:
  - review
sr-due: 2026-03-13
sr-interval: 58
sr-ease: 250
---
Каждая программа в [[Linux]] при запуске открывает 3 потока — это файлы, но особенные:

| Название | Описание           | Номер дескриптора |
| -------- | ------------------ | ----------------- |
| `stdin`  | Стандартный ввод   | 0                 |
| `stdout` | Стандартный вывод  | 1                 |
| `stderr` | Стандартная ошибка | 2                 |
Поток стандартного вывода можно перенаправить в файл. В том числе и специальный, например как: 
`/dev/null` — это специальный файл в [[Linux]]/Unix-системах, который действует как "черная дыра":  
- Всё, что в него записывается, бесследно исчезает.  
- При чтении из него сразу получается пустота (как конец файла).  
По сути, это способ игнорировать вывод программ или ошибки.  

Для этого можно использовать символы перенаправления 
- `result > file` - Перенаправить в файл с перезаписью 
    1. Содержимое файла удаляется 
    2. Происходит запись новой информации
- `result >> file` - Добавление в файл (будет добавлено в конец файла)
- `result | program` - Конвейер (`stdout` первой программы перенаправляется на `stdin` второй программы)
- `result | tee file | program` - Тройник для данных. Перенаправляет `stdin` в файл и одновременно на свой `stdout`, то есть выводит сразу на экран и записывает в файл.
- `result | sudo tee file | program` - Тройник для данных. Перенаправляет `stdin `в файл который имеет возможность записать только root и одновременно на свой `stdout`

`command < file` - Для `stdin` можно использовать символ перенаправления

Для `stderr`:
- `result 2> file` - С перезаписью 
- `result 2>> file` - С добавлением 
- `result 2>&1 file` - присоединить к `stdout`

>[!info]  Самый простой способ создать файл
> `>file`

Интересный пример:

```bash
y1g0ul@DESKTOP-195S4U1:~$ touch file{1..3}
y1g0ul@DESKTOP-195S4U1:~$ ls
dir  file1  file2  file3
y1g0ul@DESKTOP-195S4U1:~$ ls -l > stdout
y1g0ul@DESKTOP-195S4U1:~$ cat stdout
total 4
drwxr-xr-x 2 y1g0ul y1g0ul 4096 Dec  5 08:59 dir
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file1
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file2
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file3
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 stdout
```

Как мы видим при выводе содержимого файла, информация о нем уже есть внутри. Все потому что перед выполнением команды сначала обрабатывает перенаправления. У нас сначала создается файл а потом уже выполняется команда [[ls]].

```bash
y1g0ul@DESKTOP-195S4U1:~$ ls -l > stdout
y1g0ul@DESKTOP-195S4U1:~$ cat stdout
total 4
drwxr-xr-x 2 y1g0ul y1g0ul 4096 Dec  5 08:59 dir
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file1
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file2
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:17 file3
-rw-r--r-- 1 y1g0ul y1g0ul    0 Dec  8 11:26 stdout
```

При этом если мы еще раз выпоним команду то размер файла так и будет нулевым потому что при выполнении команды он был перезаписан.