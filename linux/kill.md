---
created-dt: 2025-08-18 13:04
tags:
  - review
sr-due: 2026-04-01
sr-interval: 54
sr-ease: 250
---
Команда в [[Linux]] которая позволяет отправить [[сигнал]] [[процесс]]у

```bash
y1g0ul@LAPTOP-MSSNKT4E:~$ sleep 1000 &
[1] 23
y1g0ul@LAPTOP-MSSNKT4E:~$ ps -efl
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
0 S root         1     0  0  80   0 -  2238 ?      12:49 ?        00:00:00 /init
0 S root         8     1  0  80   0 -  2238 ?      12:49 tty1     00:00:00 /init
0 S y1g0ul       9     8  0  80   0 -  3528 ?      12:49 tty1     00:00:00 -bash
0 S y1g0ul      23     9  0  80   0 -  2791 ?      12:50 tty1     00:00:00 sleep 1000
0 R y1g0ul      24     9  0  80   0 -  4090 ?      12:51 tty1     00:00:00 ps -efl
y1g0ul@LAPTOP-MSSNKT4E:~$ kill -9 23
```

> [!info] Почему команда называется `kill`, если она просто отправляет сигнал?
>#### Немного истории UNIX:
>В ранних версиях Unix действительно была команда `kill`, которая использовалась только для завершения [[процесс]]ов.
>
>То есть: `kill PID` = «Убей [[процесс]]».
>Это отправляло [[сигнал]] по умолчанию → `SIGTERM` (мягкое завершение).
>
>С развитием системы [[сигнал]]ов, оказалось, что [[сигнал]]ы бывают не только «убей»,но и «поставь на паузу», «перезапусти», «ничего не делай», «просто проверь» и т.д. 
>Тогда стало логично - пусть команда `kill` может отправлять любой [[сигнал]], не только «убивающий».
>##### UNIX и [[Linux]] устроены так:
**Никогда не ломай совместимость.**
Если в 1970-х появилась команда `kill`, а ты через неё управлял [[процесс]]ами в своих скриптах, то спустя 50 лет эта команда должна работать точно так же, иначе твои скрипты сломаются.

